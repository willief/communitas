name: Release Summary

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  summarize:
    name: Summarize Headless + Desktop
    runs-on: ubuntu-latest
    steps:
      - name: Wait for headless + desktop and update release
        uses: actions/github-script@v7
        env:
          TAG_REF: ${{ github.ref }}
        with:
          github-token: ${{ secrets.GH_RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const tag = process.env.TAG_REF.replace('refs/tags/','');
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function getWorkflowId(path) {
              try {
                const wf = await github.rest.actions.getWorkflow({ owner, repo, workflow_id: path });
                return wf.data.id;
              } catch (e) { return null; }
            }

            async function waitWorkflow(path, label) {
              const id = await getWorkflowId(path);
              const maxMs = 45 * 60 * 1000; // 45 minutes
              const interval = 15000;
              let waited = 0;
              let lastUrl = '';
              if (!id) return { label, status: 'missing', url: '' };
              while (waited <= maxMs) {
                const runs = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: id, event: 'push', per_page: 10, branch: tag });
                const run = runs.data.workflow_runs.find(r => r.head_branch === tag) || runs.data.workflow_runs[0];
                if (run) {
                  lastUrl = run.html_url;
                  if (run.status === 'completed') return { label, status: run.conclusion || 'completed', url: lastUrl };
                }
                await new Promise(r => setTimeout(r, interval));
                waited += interval;
              }
              return { label, status: 'timeout', url: lastUrl };
            }

            async function waitForRelease() {
              const maxMs = 30 * 60 * 1000; // 30 minutes
              const interval = 15000;
              let waited = 0;
              while (waited <= maxMs) {
                try {
                  const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                  return rel.data;
                } catch (e) {
                  if (e.status !== 404) throw e;
                  await new Promise(r => setTimeout(r, interval));
                  waited += interval;
                }
              }
              throw new Error('Timed out waiting for release to exist');
            }

            const [headless, desktop] = await Promise.all([
              waitWorkflow('release-headless.yml', 'Headless'),
              waitWorkflow('tauri-release.yml', 'Desktop'),
            ]);

            const rel = await waitForRelease();
            const when = new Date().toISOString();
            const summary = `\n\n## Build Summary (auto)\n- Headless: ${headless.status} ${headless.url ? `(${headless.url})` : ''}\n- Desktop: ${desktop.status} ${desktop.url ? `(${desktop.url})` : ''}\n\nGenerated: ${when}`;

            const body = (rel.body || '');
            const newBody = body.includes('## Build Summary (auto)') ? body.replace(/## Build Summary \(auto\)[\s\S]*/m, summary) : (body + summary);
            await github.rest.repos.updateRelease({ owner, repo, release_id: rel.id, body: newBody });

            core.info(`Updated release ${rel.tag_name} with summary.`);
