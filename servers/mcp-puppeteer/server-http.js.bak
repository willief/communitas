#!/usr/bin/env node
// MCP server (HTTP transport) to drive Communitas via Puppeteer.
// Useful when clients canâ€™t use stdio transports.

import puppeteer from 'puppeteer';
import { z } from 'zod';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import http from 'node:http';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';

const DEFAULT_URL = process.env.MCP_BROWSER_URL || 'http://localhost:1420';
const HEADLESS = process.env.MCP_BROWSER_HEADLESS === '1';
const HOST = process.env.MCP_HTTP_HOST || '127.0.0.1';
const PORT = Number(process.env.MCP_HTTP_PORT || 8765);

let browser = null;
let page = null;

// Crash diagnostics to logs (picked up by /tmp/communitas-mcp-http.log)
process.on('unhandledRejection', (reason) => {
  console.error('[mcp-http] UnhandledRejection:', reason);
});
process.on('uncaughtException', (err) => {
  console.error('[mcp-http] UncaughtException:', err);
});

async function ensureBrowser() {
  if (!browser) {
    const executablePath = process.env.PUPPETEER_EXECUTABLE_PATH || undefined;
    const launchOpts = {
      headless: HEADLESS,
      defaultViewport: { width: 1400, height: 900 },
      args: ['--no-sandbox', '--disable-dev-shm-usage'],
      executablePath,
    };
    console.log('[mcp-http] Launching Puppeteer', { headless: HEADLESS, executablePath: executablePath ? 'custom' : 'default' });
    browser = await puppeteer.launch(launchOpts);
  }
  if (!page) {
    page = await browser.newPage();
    page.on('console', msg => {
      const type = msg.type();
      if (type === 'error') {
        console.error('[browser:error]', msg.text());
      } else {
        console.log(`[browser:${type}]`, msg.text());
      }
    });
  }
  return { browser, page };
}

const server = new McpServer({ name: 'communitas-mcp-puppeteer-http', version: '0.1.0' });

// Register tools (same as stdio server)
server.registerTool(
  'browser_navigate',
  { title: 'Navigate to URL', description: 'Navigate the browser to a URL', inputSchema: { url: z.string().url() } },
  async ({ url }) => {
    const { page } = await ensureBrowser();
    await page.goto(url, { waitUntil: 'networkidle2' });
    const title = await page.title();
    return { content: [{ type: 'text', text: `Navigated to ${url}\nTitle: ${title}` }] };
  }
);

server.registerTool(
  'browser_wait_for',
  { title: 'Wait for selector', description: 'Wait until a selector appears', inputSchema: { selector: z.string(), timeoutMs: z.number().int().positive().optional() } },
  async ({ selector, timeoutMs }) => {
    const { page } = await ensureBrowser();
    await page.waitForSelector(selector, { timeout: timeoutMs ?? 10000 });
    return { content: [{ type: 'text', text: `Selector present: ${selector}` }] };
  }
);

server.registerTool(
  'browser_click',
  { title: 'Click element', description: 'Click an element by CSS selector', inputSchema: { selector: z.string() } },
  async ({ selector }) => {
    const { page } = await ensureBrowser();
    await page.click(selector, { delay: 10 });
    return { content: [{ type: 'text', text: `Clicked ${selector}` }] };
  }
);

server.registerTool(
  'browser_click_text',
  { title: 'Click element by text', description: 'Find clickable element by textContent and click', inputSchema: { text: z.string().min(1) } },
  async ({ text }) => {
    const { page } = await ensureBrowser();
    const found = await page.evaluateHandle((t) => {
      const els = Array.from(document.querySelectorAll('button, [role="button"], a, *'));
      return els.find((el) => (el.textContent || '').includes(t));
    }, text);
    const exists = await found.evaluate((el) => !!el);
    if (!exists) {
      return { content: [{ type: 'text', text: `No element with text including: ${text}` }] };
    }
    await found.click();
    return { content: [{ type: 'text', text: `Clicked element containing text: ${text}` }] };
  }
);

// browser_wait_text
server.registerTool(
  'browser_wait_text',
  {
    title: 'Wait for text',
    description: 'Wait until given text appears in document',
    inputSchema: { text: z.string().min(1), timeoutMs: z.number().int().positive().optional() },
  },
  async ({ text, timeoutMs }) => {
    const { page } = await ensureBrowser();
    await page.waitForFunction(
      (t) => document.body && document.body.innerText && document.body.innerText.includes(t),
      { timeout: timeoutMs ?? 8000 },
      text,
    );
    return { content: [{ type: 'text', text: `Text present: ${text}` }] };
  }
);

// browser_fill
server.registerTool(
  'browser_fill',
  {
    title: 'Fill input',
    description: 'Type into an input/textarea matched by selector',
    inputSchema: { selector: z.string(), value: z.string() },
  },
  async ({ selector, value }) => {
    const { page } = await ensureBrowser();
    await page.focus(selector);
    await page.evaluate((sel) => {
      const el = document.querySelector(sel);
      if (el) { (el).value = ''; }
    }, selector);
    await page.type(selector, value);
    return { content: [{ type: 'text', text: `Filled ${selector}` }] };
  }
);

// browser_query_all_texts
server.registerTool(
  'browser_query_all_texts',
  {
    title: 'Query all texts',
    description: 'Return textContent array for selector',
    inputSchema: { selector: z.string() },
  },
  async ({ selector }) => {
    const { page } = await ensureBrowser();
    const texts = await page.$$eval(selector, els => els.map(el => (el.textContent || '').trim()).filter(Boolean));
    return { content: [{ type: 'text', text: JSON.stringify(texts) }] };
  }
);

server.registerTool(
  'browser_type',
  { title: 'Type into element', description: 'Type text into input/textarea', inputSchema: { selector: z.string(), text: z.string() } },
  async ({ selector, text }) => {
    const { page } = await ensureBrowser();
    await page.focus(selector);
    await page.type(selector, text);
    return { content: [{ type: 'text', text: `Typed into ${selector}: ${text}` }] };
  }
);

server.registerTool(
  'browser_snapshot',
  { title: 'Take screenshot', description: 'Capture screenshot and return as base64', inputSchema: { fullPage: z.boolean().optional() } },
  async ({ fullPage }) => {
    const { page } = await ensureBrowser();
    const buf = await page.screenshot({ fullPage: !!fullPage, type: 'png' });
    const b64 = Buffer.from(buf).toString('base64');
    return { content: [{ type: 'text', text: 'Screenshot captured (base64 PNG)' }, { type: 'image', data: b64, mimeType: 'image/png' }] };
  }
);

server.registerTool(
  'browser_eval',
  { title: 'Evaluate JavaScript', description: 'Run JS in page and return result', inputSchema: { script: z.string() } },
  async ({ script }) => {
    const { page } = await ensureBrowser();
    const result = await page.evaluate((code) => { const fn = new Function(`return (${code});`); const val = fn(); return typeof val === 'string' ? val : JSON.stringify(val); }, script);
    return { content: [{ type: 'text', text: String(result) }] };
  }
);

async function ensureAppNavigated() {
  const { page } = await ensureBrowser();
  if (page.url() === 'about:blank') {
    await page.goto(DEFAULT_URL, { waitUntil: 'networkidle2' });
  }
  return page;
}

const appTools = [
  { name: 'app_test_identity', desc: 'Run window.testIdentity.testFlow()', eval: () => (window.testIdentity?.testFlow ? window.testIdentity.testFlow() : 'testIdentity not available') },
  { name: 'app_setup_workspace', desc: 'Run window.workspace.setup()', eval: () => (window.workspace?.setup ? window.workspace.setup() : 'workspace not available') },
  { name: 'app_test_groups', desc: 'Run window.tauriGroups.test()', eval: () => (window.tauriGroups?.test ? window.tauriGroups.test() : 'tauriGroups not available') },
  { name: 'app_test_group_messaging', desc: 'Run window.tauriGroups.testMessaging()', eval: () => (window.tauriGroups?.testMessaging ? window.tauriGroups.testMessaging() : 'tauriGroups not available') },
  { name: 'app_offline_simulate', desc: 'Run window.offlineTest.simulate()', eval: () => (window.offlineTest?.simulate ? window.offlineTest.simulate() : 'offlineTest not available') },
  { name: 'app_list_groups', desc: 'Run window.tauriGroups.listGroups()', eval: () => (window.tauriGroups?.listGroups ? window.tauriGroups.listGroups() : 'tauriGroups not available') },
  { name: 'app_offline_stats', desc: 'Get window.offlineTest.storage.getStats()', eval: () => (window.offlineTest?.storage?.getStats ? window.offlineTest.storage.getStats() : 'offlineTest not available') },
  { name: 'app_click_tab', desc: 'Click a top-level tab by visible text', eval: (tabName) => {
      const btns = Array.from(document.querySelectorAll('button'));
      const el = btns.find(b => (b.textContent || '').trim().includes(tabName));
      if (el) { el.click(); return `clicked:${tabName}`; }
      return `not_found:${tabName}`;
    }
  },
  { name: 'app_offline_full_flow', desc: 'Run full offline flow', eval: async () => {
      const ws = window.workspace;
      const ot = window.offlineTest;
      if (!ws || !ws.setup || !ot || !ot.test) return 'offline utilities not available';
      const setup = await ws.setup();
      const test = await ot.test();
      await ws.list();
      return { setup, test, listed: true };
    }
  },
];

for (const tool of appTools) {
  const schema = tool.name === 'app_click_tab' ? { tabName: z.string().min(1) } : {};
  server.registerTool(tool.name, { title: tool.name, description: tool.desc, inputSchema: schema }, async (args) => {
    const page = await ensureAppNavigated();
    const result = tool.name === 'app_click_tab'
      ? await page.evaluate(tool.eval, args.tabName)
      : await page.evaluate(tool.eval);
    const text = typeof result === 'string' ? result : JSON.stringify(result);
    return { content: [{ type: 'text', text }] };
  });
}

// Create transport and HTTP server that forwards requests to transport
const transport = new StreamableHTTPServerTransport({ enableJsonResponse: true });
await server.connect(transport);

const httpServer = http.createServer(async (req, res) => {
  try {
    // Let transport handle body parsing per spec; don't pre-parse here
    await transport.handleRequest(req, res, undefined);
  } catch (e) {
    res.statusCode = 500;
    res.end(JSON.stringify({ error: String(e?.message || e) }));
  }
});

httpServer.listen(PORT, HOST, () => {
  console.log(`MCP HTTP server listening at http://${HOST}:${PORT}`);
});

process.on('SIGINT', async () => {
  if (browser) await browser.close().catch(() => {});
  process.exit(0);
});
